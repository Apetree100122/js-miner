package burp;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static burp.BurpExtender.mStdErr;

/**
 * Class to find interesting stuff in JavaScript & JSON files
 */

public class InterestingStuffFinder implements Runnable {
    private static final IBurpExtenderCallbacks callbacks = BurpExtender.getCallbacks();
    private static final IExtensionHelpers helpers = callbacks.getHelpers();
    private final IHttpRequestResponse[] baseRequestResponseArray;
    private static final String WHITE_SPACES = "(\\s*)";

    private static final Pattern CLOUD_URLS_REGEX = Pattern.compile("([\\w]+[.]){1,10}" + // get up to 10 subdomain levels
                    "(s3.amazonaws.com|rds.amazonaws.com|cache.amazonaws.com|" + // AWS
                    "blob.core.windows.net|onedrive.live.com|1drv.com|" + // Azure
                    "storage.googleapis.com|storage.cloud.google.com|storage-download.googleapis.com|content-storage-upload.googleapis.com|content-storage-download.googleapis.com|" + // Google
                    "cloudfront.net|" +
                    "digitaloceanspaces.com|" +
                    "oraclecloud.com|" +
                    "aliyuncs.com|" + // Ali baba
                    "firebaseio.com|" + // Firebase
                    "rackcdn.com|" +
                    "objects.cdn.dream.io|objects-us-west-1.dream.io)",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    // Inspired by: https://github.com/nsonaniya2010/SubDomainizer/blob/master/SubDomainizer.py
    private static final Pattern SECRETS_REGEX = Pattern.compile(("['\"`]?(\\w*)" + // Starts with a quote then a word / white spaces
                    WHITE_SPACES +
                    "(secret|token|password|passwd|authorization|bearer|aws_access_key_id|aws_secret_access_key|irc_pass|SLACK_BOT_TOKEN|id_dsa" +
                    "secret[_-]?(key|token|secret)|" +
                    "api[_-]?(key|token|secret)|" +
                    "access[_-]?(key|token|secret)|" +
                    "auth[_-]?(key|token|secret)|" +
                    "session[_-]?(key|token|secret)|" +
                    "consumer[_-]?(key|token|secret)|" +
                    "private[_-]?(key|token|secret)|" +
                    "client[_-]?(id|token|key)|" +
                    "ssh[_-]?key|" +
                    "encrypt[_-]?(secret|key)|" +
                    "decrypt[_-]?(secret|key)|" +
                    "github[_-]?(key|token|secret)|" +
                    "slack[_-]?token)" +
                    "(\\w*)" + // in case there are any characters / white spaces
                    WHITE_SPACES +
                    "['\"`]?" + // closing quote for variable name
                    WHITE_SPACES +// white spaces
                    "[:=]+[:=>]?" +// assignments operation
                    WHITE_SPACES +
                    "['\"`]" + // opening quote for secret
                    WHITE_SPACES +
                    "([\\w\\-/~!@#$%^&*+]+)" + // Assuming secrets will be alphanumeric with some special characters
                    WHITE_SPACES +
                    "['\"`]" // closing quote for secrets
            ),
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    private static final String SCAN_ISSUE_HEADER = "This issue was generated by \"" + BurpExtender.EXTENSION_NAME + "\" Burp extension.<br><br>";
    private static final String CONFIDENCE_CERTAIN = "Certain";
    private static final String CONFIDENCE_TENTATIVE = "Tentative";
    private static final String CONFIDENCE_FIRM = "Firm";
    private static final String SEVERITY_INFORMATION = "Information";
    private static final String SEVERITY_MEDIUM = "Medium";
    private static final String HTML_LIST_OPEN = "<ul>";
    private static final String HTML_LIST_BULLET_OPEN = "<li> ";
    private static final String HTML_LIST_BULLET_CLOSED = "</li>";
    private static final String HTML_LIST_CLOSED = "</ul>";


    InterestingStuffFinder(IHttpRequestResponse[] baseRequestResponseArray) {
        this.baseRequestResponseArray = baseRequestResponseArray;
    }

    public void run() {
        try {
            for (IHttpRequestResponse baseRequestResponse : baseRequestResponseArray) {
                // only process ".js" and ".json" files
                if (baseRequestResponse.getResponse() != null
                        &&
                        (
                                (helpers.analyzeRequest(baseRequestResponse).getUrl().getPath().endsWith(".js"))
                                        || (helpers.analyzeRequest(baseRequestResponse).getUrl().getPath().endsWith(".json"))
                        )
                        && BurpExtender.isLoaded()
                ) {
                    String responseString = new String(baseRequestResponse.getResponse());
                    String responseBodyString = responseString.substring(helpers.analyzeResponse(baseRequestResponse.getResponse()).getBodyOffset());
                    mainHandler(baseRequestResponse, responseBodyString);

                }
            }
        } catch (Exception e) {
            try {
                throw e;
            } catch (Exception ex) {
                mStdErr.println("InterestingStuffFinder run Exception");
            }
        }
    }

    private void mainHandler(IHttpRequestResponse baseRequestResponse, String responseBodyString) {
        findSecrets(baseRequestResponse, responseBodyString);
        findSubDomains(baseRequestResponse, responseBodyString);
        findCloudURLs(baseRequestResponse, responseBodyString);
    }

    /**
     * Scan function 1 - Check all strings for potential secrets (uses Shannon Entropy to increase confidence)
     */
    private void findSecrets(IHttpRequestResponse baseRequestResponse, String responseBodyString) {

        Matcher matcherSecrets = SECRETS_REGEX.matcher(responseBodyString);
        while (matcherSecrets.find() && BurpExtender.isLoaded()) {
            List<int[]> secretsMatches = Utilities.getMatches(baseRequestResponse.getResponse(), helpers.stringToBytes(matcherSecrets.group()));
            double entropy = Utilities.getShannonEntropy(matcherSecrets.group(20)); // group(2) matches our secret
            if (entropy >= 3.5) {
                // if high entropy, confidence is "Firm"
                IScanIssue secretsCustomScanIssue = new CustomScanIssue(
                        baseRequestResponse.getHttpService(),
                        helpers.analyzeRequest(baseRequestResponse).getUrl(),
                        new IHttpRequestResponse[]{callbacks.applyMarkers(baseRequestResponse, null, secretsMatches)},
                        "[JS Miner] Secrets / Credentials",
                        SCAN_ISSUE_HEADER +
                                "The following secrets / credentials has high entropy and it was found in a JavaScript file." +
                                HTML_LIST_OPEN +
                                HTML_LIST_BULLET_OPEN + matcherSecrets.group() + HTML_LIST_BULLET_CLOSED +
                                HTML_LIST_CLOSED +
                                "The identified secrets are also highlighted in the HTTP response.<br>" +
                                "<br>",
                        null,
                        SEVERITY_MEDIUM,
                        CONFIDENCE_FIRM);
                Utilities.reportIssueIfNotDuplicate(secretsCustomScanIssue, baseRequestResponse);
            } else {
                // if low entropy, confidence is "Tentative"
                IScanIssue secretsCustomScanIssue = new CustomScanIssue(
                        baseRequestResponse.getHttpService(),
                        helpers.analyzeRequest(baseRequestResponse).getUrl(),
                        new IHttpRequestResponse[]{callbacks.applyMarkers(baseRequestResponse, null, secretsMatches)},
                        "[JS Miner] Secrets / Credentials",
                        SCAN_ISSUE_HEADER +
                                "The following secrets / credentials has high entropy and it was found in a JavaScript file." +
                                HTML_LIST_OPEN +
                                HTML_LIST_BULLET_OPEN + matcherSecrets.group() + HTML_LIST_BULLET_CLOSED +
                                HTML_LIST_CLOSED +
                                "The identified secrets are also highlighted in the HTTP response.<br>" +
                                "<br>",
                        null,
                        SEVERITY_MEDIUM,
                        CONFIDENCE_TENTATIVE);
                Utilities.reportIssueIfNotDuplicate(secretsCustomScanIssue, baseRequestResponse);
            }
        }
    }

    /**
     * Scan function 2 - Get all subdomains
     */
    private void findSubDomains(IHttpRequestResponse baseRequestResponse, String responseBodyString) {

        String requestDomain = helpers.analyzeRequest(baseRequestResponse).getUrl().getHost();
        // Get root Domain (e.g.: example.com instead of sub.example.com)
        Pattern rootDomainRegex = Pattern.compile("[a-z0-9]+.[a-z0-9]+$", Pattern.CASE_INSENSITIVE);
        Matcher matcherRootDomain = rootDomainRegex.matcher(requestDomain);
        if (matcherRootDomain.find() && BurpExtender.isLoaded()) {
            String rootDomain = matcherRootDomain.group();
            // Simple SubDomains Regex
            Pattern subDomainsRegex = Pattern.compile("([a-z0-9]+[.])+" + rootDomain, Pattern.CASE_INSENSITIVE);
            Matcher matcherSubDomains = subDomainsRegex.matcher(responseBodyString);
            while (matcherSubDomains.find() && BurpExtender.isLoaded()) {
                if (!matcherSubDomains.group().equals("www." + requestDomain)
                        && !matcherSubDomains.group().equals(requestDomain)
                        && !matcherSubDomains.group().equals("www." + rootDomain)) {
                    // Get markers of found subdomains
                    List<int[]> subDomainsMatches = Utilities.getMatches(baseRequestResponse.getResponse(), matcherSubDomains.group().getBytes());
                    // report the issue
                    if (!subDomainsMatches.isEmpty()) {
                        IScanIssue subDomainsCustomScanIssue = new CustomScanIssue(
                                baseRequestResponse.getHttpService(),
                                helpers.analyzeRequest(baseRequestResponse).getUrl(),
                                new IHttpRequestResponse[]{callbacks.applyMarkers(baseRequestResponse, null, subDomainsMatches)},
                                "[JS Miner] Subdomains",
                                SCAN_ISSUE_HEADER +
                                        "The following subdomain was found in a JavaScript file." +
                                        HTML_LIST_OPEN +
                                        HTML_LIST_BULLET_OPEN + helpers.urlDecode(matcherSubDomains.group()) + HTML_LIST_BULLET_CLOSED +
                                        HTML_LIST_CLOSED +
                                        "The identified subdomains are also highlighted in the HTTP response.<br>" +
                                        "<br>",
                                null,
                                SEVERITY_INFORMATION,
                                CONFIDENCE_CERTAIN);
                        Utilities.reportIssueIfNotDuplicate(subDomainsCustomScanIssue, baseRequestResponse);
                    }
                }
            }
        }

    }

    /**
     * Scan function 3 - Get Cloud URLs
     */
    private void findCloudURLs(IHttpRequestResponse baseRequestResponse, String responseBodyString) {

        Matcher cloudURLsMatcher = CLOUD_URLS_REGEX.matcher(responseBodyString);
        while (cloudURLsMatcher.find() && BurpExtender.isLoaded()) {
            // Get markers of found Cloud URL Matches
            List<int[]> cloudHostsMatches = Utilities.getMatches(baseRequestResponse.getResponse(), cloudURLsMatcher.group().getBytes());
            // report the issue
            if (!cloudHostsMatches.isEmpty()) {
                IScanIssue cloudURLsCustomIssue = new CustomScanIssue(
                        baseRequestResponse.getHttpService(),
                        helpers.analyzeRequest(baseRequestResponse).getUrl(),
                        new IHttpRequestResponse[]{callbacks.applyMarkers(baseRequestResponse, null, cloudHostsMatches)},
                        "[JS Miner] Cloud Resources",
                        SCAN_ISSUE_HEADER +
                                "The following  cloud URL was found in a JavaScript file." +
                                HTML_LIST_OPEN +
                                HTML_LIST_BULLET_OPEN + cloudURLsMatcher.group() + HTML_LIST_BULLET_CLOSED +
                                HTML_LIST_CLOSED +
                                "The identified URLs are highlighted in the HTTP response.<br><br>" +
                                "<br>",
                        null,
                        SEVERITY_INFORMATION,
                        CONFIDENCE_CERTAIN);
                Utilities.reportIssueIfNotDuplicate(cloudURLsCustomIssue, baseRequestResponse);
            }
        }
    }
}
